{
  "version": 3,
  "sources": ["../../@vaadin/react-components/src/renderers/useRenderer.ts", "../../@vaadin/react-components/src/renderers/useModelRenderer.ts"],
  "sourcesContent": ["import {\n  type ComponentType,\n  createElement,\n  type PropsWithChildren,\n  type ReactElement,\n  type ReactNode,\n  useCallback,\n  useReducer,\n} from 'react';\nimport { createPortal, flushSync } from 'react-dom';\nimport type { Slice, WebComponentRenderer } from './renderer.js';\n\nexport type UseRendererResult<W extends WebComponentRenderer> = readonly [\n  portals?: ReadonlyArray<ReactElement | null>,\n  renderer?: W,\n];\n\nconst initialState = new Map();\n\nfunction rendererReducer<W extends WebComponentRenderer>(\n  state: Map<HTMLElement, Slice<Parameters<W>, 1>>,\n  [root, ...args]: Parameters<W>,\n): Map<HTMLElement, Slice<Parameters<W>, 1>> {\n  return new Map(state).set(root, args as Slice<Parameters<W>, 1>);\n}\n\nexport type RendererConfig = {\n  renderSync?: boolean;\n};\n\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  node: ReactNode,\n  convert?: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig,\n): UseRendererResult<W>;\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  reactRenderer: ComponentType<P> | null | undefined,\n  convert: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig,\n): UseRendererResult<W>;\nexport function useRenderer<P extends {}, W extends WebComponentRenderer>(\n  reactRendererOrNode: ReactNode | ComponentType<P> | null | undefined,\n  convert?: (props: Slice<Parameters<W>, 1>) => PropsWithChildren<P>,\n  config?: RendererConfig,\n): UseRendererResult<W> {\n  const [map, update] = useReducer<typeof rendererReducer<W>>(rendererReducer, initialState);\n  const renderer = useCallback(\n    ((...args: Parameters<W>) => {\n      if (config?.renderSync) {\n        // The web components may request multiple synchronous renderer calls that\n        // would result in flushSync logging a warning (and actually executing the\n        // overlapping flushSync in microtask timing). Suppress the warning and allow\n        // the resulting asynchronicity.\n        const console = globalThis.console as any;\n        const error = console.error;\n        console.error = (message: string) => {\n          if (message.includes('flushSync')) {\n            return;\n          }\n          error(message);\n        };\n        flushSync(() => update(args));\n        console.error = error;\n      } else {\n        update(args);\n      }\n    }) as W,\n    [],\n  );\n\n  return reactRendererOrNode\n    ? [\n        Array.from(map.entries()).map(([root, args]) =>\n          createPortal(\n            convert\n              ? createElement<P>(reactRendererOrNode as ComponentType<P>, convert(args))\n              : (reactRendererOrNode as ReactNode),\n            root,\n          ),\n        ),\n        renderer,\n      ]\n    : [];\n}\n", "import type { ComponentType } from 'react';\nimport type { Slice } from './renderer.js';\nimport { useRenderer, type RendererConfig, type UseRendererResult } from './useRenderer.js';\n\nexport type Model<I> = Readonly<{\n  item: I;\n}>;\n\nexport type ReactModelRendererProps<I, M extends Model<I>, O extends HTMLElement> = Readonly<{\n  item: I;\n  model: M;\n  original: O;\n}>;\n\nexport type WebComponentModelRenderer<I, M extends Model<I>, O extends HTMLElement> = (\n  root: HTMLElement,\n  original: O,\n  model: M,\n) => void;\n\nexport function convertModelRendererArgs<I, M extends Model<I>, O extends HTMLElement>([original, model]: Slice<\n  Parameters<WebComponentModelRenderer<I, M, O>>,\n  1\n>): ReactModelRendererProps<I, M, O> {\n  return { item: model.item, model, original };\n}\n\nexport function useModelRenderer<I, M extends Model<I>, O extends HTMLElement>(\n  reactRenderer?: ComponentType<ReactModelRendererProps<I, M, O>> | null,\n  config?: RendererConfig,\n): UseRendererResult<WebComponentModelRenderer<I, M, O>> {\n  return useRenderer(reactRenderer, convertModelRendererArgs, config);\n}\n"],
  "mappings": ";;;;;;;;;;;AAAA,mBAQO;AACP,uBAAwC;AAQxC,IAAMA,IAAe,oBAAI;AAEzB,SAASC,EACPC,GACA,CAACC,GAAM,GAAGC,EAAI,GAC6B;AAC3C,SAAO,IAAI,IAAIF,CAAK,EAAE,IAAIC,GAAMC,EAA+B;AACjE;AAgBO,SAASC,EACdC,GACAC,GACAC,IACsB;AACtB,QAAM,CAACC,GAAKC,CAAM,QAAIC,aAAAA,YAAsCV,GAAiBD,CAAY,GACnFY,QAAWC,aAAAA,aACd,IAAIT,MAAwB;AAC3B,QAAII,MAAAA,gBAAAA,GAAQ,YAAY;AAKtB,YAAMM,IAAU,WAAW,SACrBC,KAAQD,EAAQ;AACtBA,QAAQ,QAASE,OAAoB;AAC/BA,UAAQ,SAAS,WAAW,KAGhCD,GAAMC,CAAO;MACf,OACAC,iBAAAA,WAAU,MAAMP,EAAON,CAAI,CAAC,GAC5BU,EAAQ,QAAQC;IAClB,MACEL,GAAON,CAAI;EAEf,GACA,CAAC,CACH;AAEA,SAAOE,IACH,CACE,MAAM,KAAKG,EAAI,QAAQ,CAAC,EAAE,IAAI,CAAC,CAACN,GAAMC,CAAI,UACxCc,iBAAAA,cACEX,QACIY,aAAAA,eAAiBb,GAAyCC,EAAQH,CAAI,CAAC,IACtEE,GACLH,CACF,CACF,GACAS,CACF,IACA,CAAC;AACP;;;AC/DO,SAASQ,EAAuE,CAACC,GAAUC,CAAK,GAGlE;AACnC,SAAO,EAAE,MAAMA,EAAM,MAAM,OAAAA,GAAO,UAAAD,EAAS;AAC7C;AAEO,SAASE,EACdC,GACAC,GACuD;AACvD,SAAOC,EAAYF,GAAeJ,GAA0BK,CAAM;AACpE;",
  "names": ["initialState", "rendererReducer", "state", "root", "args", "useRenderer", "reactRendererOrNode", "convert", "config", "map", "update", "useReducer", "renderer", "useCallback", "console", "error", "message", "flushSync", "createPortal", "createElement", "convertModelRendererArgs", "original", "model", "useModelRenderer", "reactRenderer", "config", "useRenderer"]
}
